# UML Class Diagram

The diagram below summarizes the main runtime classes that power the playable loop in `game.py`. It focuses on how the orchestrating game loop composes the environment model (`Board`), the player avatar, and the collection of ghosts that inherit from `pygame.sprite.Sprite`.

```mermaid
classDiagram
    class Sprite {
        <<pygame>>
    }

    class GameLoop {
        <<module>>
        -ghosts : List<Ghost>
        -player : Player
        -board : Board
        -is_running : bool
        -counter : int
        +run()
        +handle_events()
        +update_entities()
    }

    class Board {
        -board : List[List[Tuple[int, List[int], bool]]]
        -score : int
        -lives : int
        -gameStart : bool
        -game_over : bool
        -game_won : bool
        +detect_eat(x, y)
        +canMove(x, y)
        +ifTouched(px, py, gx, gy, attacked)
        +ifCollision(x, y, dx, dy)
        +bfs_setdir(ghost, target)
        +draw_environment(screen)
        +draw_score_and_lives(screen, font)
        +draw_game_over_or_won(screen, font)
    }

    class Player {
        +player_x : float
        +player_y : float
        +dx : int
        +dy : int
        +direction : int
        +player_speed : int
        +control : int
        +draw(counter, screen, canMove)
        +update(direction, canMove, intersected, collision)
    }

    class ScriptedPlayer {
        +loop_script : bool
        +consume_scripted_move(canMove)
    }

    class Ghost {
        +name : str
        +rect : pygame.Rect
        +dx : int
        +dy : int
        +algorithm : str
        +_attacked : bool
        +_attackedCounter : int
        +update()
        +set_dir(next_step, canMove)
        +_apply_bfs_step(next_step)
        +ud_set_dir(canMove, bfs_next)
        +random_set_dir(canMove)
        +set_attacked()
        +draw(screen)
    }

    class HunterGhost {
        +lock_interval : int
        +set_dir(next_step, canMove)
    }

    class ScatterGhost {
        +scatter_duration : int
        +chase_duration : int
        +set_dir(next_step, canMove)
    }

    class ScriptedGhost {
        +loop_script : bool
        +consume_scripted_move(canMove)
        +set_dir(next_step, canMove)
    }

    Sprite <|-- Player
    Player <|-- ScriptedPlayer
    Sprite <|-- Ghost
    Ghost <|-- HunterGhost
    Ghost <|-- ScatterGhost
    Ghost <|-- ScriptedGhost
    GameLoop "1" *-- "1" Board : composes
    GameLoop "1" *-- "1" Player : controls
    GameLoop "1" *-- "4" Ghost : manages
    Board ..> Player : movement state
    Board ..> Ghost : pathfinding data
```

Notes:
- `GameLoop` is drawn as a module stereotype because the logic in `game.py` is implemented procedurally rather than as a formal class. It still behaves like a controller that owns and updates the other objects.
- The `Board`’s `board` field stores, for each tile, the map symbol, allowed directions, and an “intersection” flag generated by `intersect_map`.
- Both `Player` and `Ghost` inherit from `pygame.sprite.Sprite`, which provides fundamental rendering and collision-rectangle behavior supplied by the external Pygame library.
- `HunterGhost` inherits from `Ghost` but throttles how often it can turn, which makes it commit to corridors before changing direction again.
- `ScatterGhost` alternates between random “scatter” movement and directed BFS chases, giving the blue ghost a predictable rhythm between phases.
- `ScriptedPlayer` extends `Player` and automatically replays a predetermined sequence of moves, which is useful for automated demos and tests where no keyboard input is available.
- `ScriptedGhost` extends `Ghost` so automated demos can drive ghosts through predetermined paths before falling back to the normal targeting algorithm.
